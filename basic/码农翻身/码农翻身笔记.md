



> 这本书看起来非常有意思,一本介绍技术的书,能让我看的兴趣盎然,丝毫没有瞌睡,还能引导我思考,通过本书的引导式故事让我了解到了计算机的发展历程,以及很多东西设计-->遇到问题-->改进这种发展历程的介绍方式,这种介绍方式我是十分喜欢的,所以对于非科班同学我也是极力推崇这本书的.

### 码农翻身笔记

#### 计算机的世界

##### 线程

线程（thread）是操作系统能够进行运算调度的最小单位; 它被包含在进程之中，是进程中的实际运作单位。它具有5种状态:![image-20210508162003084](https://raw.githubusercontent.com/tadpole145/images/main/image-20210508162003084.png)

单线程效率低下-->多个线程操作同一个变量--->不安全-->引入锁机制

##### TCP/IP

Transmission Control Protocol/Internet Protocol，传输控制协议/网际协议）是指能够在多个不同网络间实现信息传输的协议簇。

三次握手确认连接成功-->将数据标记编号分块运输-->每次运输收到确认指令,否则重新传输

##### CPU

中央处理器（central processing unit，简称*CPU*）作为计算机系统的运算和控制核心，是信息处理、程序运行的最终执行单元。 特点: 速度超级快,以纳秒为计算单位.

###### 两大改进:  缓存与流水线

CPU速度快,内存相对慢----> 使用寄存器缓存常用的数据,找不到再去内存取.--->每次都按照获取指令,翻译,执行,写回结果(涉及与内存交互)太慢了----> 升级为流水线,单线程变多线程操作.同时操作4个流水线.

##### 进程

*进程*（Process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。

内存只有一个程序,太慢了....每次从硬盘加载到内存非常耗时-----> 内存中同时运行多个程序---->内存地址重定位--->静态定位冲突-->地址的动态重定位---->地址访问越界---->寄存器记录程序在内存的长度,即MMU（内存管理单元）---->多进程装入内存,或者程序太大,导致内存不够用----->分块装入内存---->虚拟内存,分页装载--->分页太小了,比较繁琐---->分段+分页

##### 硬盘

特点: 能断点存储,容量大.   缺点: 读写很慢. 

文件存储--->连续空间太浪费,链表查询太麻烦--->索引式, inode来记录数据,大文件采用多个inode来记录.

![image-20210508173025070](https://raw.githubusercontent.com/tadpole145/images/main/image-20210508173025070.png)

修改数据时遇到系统崩溃,容易导致错乱----->，在操作之前，记录要做的事情，形成日志，把他们成功写入磁盘以后再正式动手操作。--->日志（Journal ）文件系统］

磁盘空闲块的管理--->位图法,使用标记1,未使用标记0

文件系统: 

![image-20210508173843818](https://i.loli.net/2021/05/08/bJ2omLME5UqfzrG.png)

##### 总线与端口

CPU与个I/O 设备通信需要连线------>多个IO设备通过总线给不同的IO设备编号(I/O 端口)来通信.---->通信慢--->引入中断请求线,主动给总线反馈(异步机制)--->反馈太乱---->中断控制器---->大文件传输到内存慢---->DMA控制器![image-20210508175221655](https://i.loli.net/2021/05/08/IcL75syuZhnWwAq.png)

##### 数据库

一种记录各个数据之间关系的数据结构.-----> 操作文件不方便---->sql（Structured Query Language）查询----->并发访问出错--->使用事务保证同步---->系统突然中断,数据出错------>使用日志记录,系统恢复时候,从日志中恢复之前的记录--->权限控制,角色分类![image-20210510092009839](https://i.loli.net/2021/05/10/WJiYyTdbIzHthmp.png)

##### Socket

对网络中不同主机上的应用进程之间进行双向通信的端点的抽象。一个套接字就是网络上进程通信的一端，提供了应用层进程利用网络协议交换数据的机制。

##### 计算机运行的本质

CPU核心主要包含运算器和寄存器,它从内存获取数据放入寄存器中计算,然后写回内存.它只能执行4种指令:

- 将数据从内存读取到寄存器;
- 进行数学运算与逻辑运算
- 根据条件进行跳转
- 将寄存器数据写回内存

数学运算就是加减乘除，逻辑运算就是AND, OR 这样的基本运算.

##### 计算机语言的发展史

最初始的001110101这种二进制----->汇编语言+汇编器---->高级语言+编译器

##### 锁

多线程共同操作同一个共享变量--->数据混乱--->锁机制--->自旋锁(如果自旋锁已经被别的执行单元保持，调用者就一直循环在那里看是否该自旋锁的保持者已经释放了锁)---->递归调用死锁--->引入计数器,调用多次则计数+n,释放一次,计数减1,直到为0,才算真正释放了锁. 这就解决了可重入性.------>无限循环等待也会浪费---->引入等待池,等锁释放了再去抢------>多线程同步操作互相等待的问题--->引入互斥锁,它使用信号量机制,“所谓信号量，真实就是一个整数，基于这个整数高两个操作：wait 和  signal函数。------>参数<0无限循环导致浪费,引入empty,full计数--->工具封装,BlockingQueue

##### 计算机的加法运算

计算机的加法就是二进制数相加,减法的本质也是加法,当减去一个数,即加上那个数的补数..比如在16进制中,7-3,3的补数是13, 原来的减法=7+13,高位溢出后放弃

补数的获取:  对二进制数所有位取反,然后+1;

负数: 二进制最高位表示符号位,0正1负, 负数采用补码表示.负0特别当作－8来处理.![image-20210510105503587](https://i.loli.net/2021/05/10/Sp8LGhtM32nYgjs.png)

##### 递归

简单来说,就是自己调用自己.函数必须要有终止条件.----->栈帧多次重复使用---->使用尾递归,复用栈帧

#### Java帝国

C语言,贴近硬件,运行效率高,但是指针和内存管理麻烦------>C++诞生,语言太复杂,图形领域和游戏使用较多,学习比较困难----->java语言诞生,使用Java虚拟机,做到跨平台使用.

- Java 2 标准版（J2SE ）：去占领桌面。
- Java 2 移动版（J2ME）：去占领手机。
- Java 2 企业版（J2EE ）：去占领服务器。

基于Java,开发了大量的平台、系统、工具。

- 构建工具： Ant、  Maven、  Jekins。
- 应用服务器： Tomcat、  Jetty、  JBoss、  WebSphere、  WebLogica
- Web 开发： Spring、  Hibernate、  MyBatis、  Struts。
- 开发工具： Eclip町、 NetBeans、  lntelliJ IDEA、  JBuilder。

##### Java Class

编译器将Java类编译成Java class,然后通过底层classLoader加载进入虚拟机,----->为避免覆盖jdk中的类,  String、  ArrayList等类只能由上层的ClassLoader加载

##### 持久化

序列化: 将对象转换为二进制文件存储到硬盘上. 缺点: 效率低-----> 使用数据库---->关联对象与数据库,产生了JDBC接口(Java Database Connectivity)------>使用起来很麻烦,于是出现了中间件------->EJB ,表面风光,实际上开发繁琐,难以测试,性能低下.----->轻量级的O/R Mapping 框架Hibernate, iBatis------>轻量级容器框架Spring,能轻松集成Hibernate, iBatis工具.----->MyBatis诞生

##### JDBC的诞生

数据库很多,更换数据库需要重写代码------>增加中间抽象层JDBC,它通过工厂方法获取数据库驱动与连接,执行sql语句然后获取结果集.

事务的4个特性,简称ACID:

- 原子性（Atomicity ）,原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚，因此事务的操作如果成功就必须要完全应用到数据库，如果操作失败则不能对数据库有任何影响。
- 一致性（Consistency ）,一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。
- 隔离性（Isolation ), 隔离性是当多个用户并发访问数据库时，比如同时操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。
- 持久性（Durability ）, 持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。

数据太多,出现多个数据库---->出现跨数据库的事务---->二阶段提交---->网络问题导致不一致------>推出Java Transaction API  ( JTA ）协议----->网络超时导致其性能低下------>取消二阶段提交,增加消息队列,事务结束,然后在队列里读取并处理消息.

![image-20210510144653150](https://i.loli.net/2021/05/10/36LEfNZTIyBDUsa.png)

##### JSP(Java server page)

把页面模板和数据装配起来，变成html发送给浏览器。------->模板引擎Freemaker和Velocity可以脱离Tomcat容器,独立展示页面----->  JavaScript的出现,直接通过http请求json数据然后在前端自己装配数据,实现前后端分离.

##### 消息队列

业务量大----->系统拆分--->网络延时,原本的同步经常遇到超时,断网等---->消息队列,异步通信------>各种队列百家争鸣---->增加消息队列接口抽象层--->开源库RabbitMQ----> 生产者消费者模型----->发布/订阅模型Java Message  Service  ( JMS )

##### 动态代理

Python、  Ruby 等语言具有动态性,能在运行时动态修改,Java并不支持---->动态代理技术, 实现共同的结果,运行时创建新的类去动态修改想要调用的方法

![image-20210510155015639](https://i.loli.net/2021/05/10/lK4aVO3W7gh5IuH.png)

![image-20210510155300120](https://i.loli.net/2021/05/10/rgw4qM97ne6H2xz.png)

缺陷: 必须要有接口才可以工作.

##### Java注解

JDK5.0 引入的一种注释机制。 Java 语言中的类、方法、变量、参数和包等都可以被标注。包含以下几种:

- 元注解(解释注解的注解),
  - @Retention  \- 标识这个注解怎么保存(源码,字节码,运行时)
  - ＠Target- 标记这个注解的目标对象
  - @Inherited - 标记这个注解是继承于哪个注解类
  - @Documented - 标记这些注解是否包含在用户文档中。
  - @Repeatable（JDK1.8加入）标识某注解可以在同一个声明上使用多次。
- jdk内置的注解,
  - @Override 
  - @Deprecated
  - @SuppressWarnings - 指示编译器去忽略注解中声明的警告。
  - @SafeVarargs - Java 7 开始支持，忽略任何使用参数为泛型变量的方法或构造函数调用产生的警告。
  - @FunctionalInterface - Java 8 开始支持，标识一个匿名函数或函数式接口。
- 用户自定义注解.

```
public @interface MyTestAnnotation {

}
```

##### 泛型

把类型明确的工作推迟到创建对象或调用方法的时候才去明确的特殊的类型,把类型当作是参数一样传递,    <数据类型> 只能是引用类型.

泛型擦除:  编译的时候强转,运行时候擦除...

三种常用的使用方式：**泛型类**，**泛型接口**和**泛型方法**。

###### 泛型类

```java
//此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型
//在实例化泛型类时，必须指定T的具体类型
public class Generic<T>{ 
    //key这个成员变量的类型为T,T的类型由外部指定  
    private T key;

    public Generic(T key) { //泛型构造方法形参key的类型也为T，T的类型由外部指定
        this.key = key;
    }

    public T getKey(){ //泛型方法getKey的返回值类型为T，T的类型由外部指定
        return key;
    }
}
```

###### 泛型接口

```java
//定义一个泛型接口
public interface Generator<T> {
    public T next();
}

/**
 * 未传入泛型实参时，与泛型类的定义相同，在声明类的时候，需将泛型的声明也一起加到类中
 * 即：class FruitGenerator<T> implements Generator<T>{
 * 如果不声明泛型，如：class FruitGenerator implements Generator<T>，编译器会报错："Unknown class"
 */
class FruitGenerator<T> implements Generator<T>{
    @Override
    public T next() {
        return null;
    }
}


/**
 * 传入泛型实参时：
 * 定义一个生产器实现这个接口,虽然我们只创建了一个泛型接口Generator<T>
 * 但是我们可以为T传入无数个实参，形成无数种类型的Generator接口。
 * 在实现类实现泛型接口时，如已将泛型类型传入实参类型，则所有使用泛型的地方都要替换成传入的实参类型
 * 即：Generator<T>，public T next();中的的T都要替换成传入的String类型。
 */
public class FruitGenerator implements Generator<String> {

    private String[] fruits = new String[]{"Apple", "Banana", "Pear"};

    @Override
    public String next() {
        Random rand = new Random();
        return fruits[rand.nextInt(3)];
    }
}
```

###### 泛型方法

```java
   //定义泛型方法..
    public <T> void show(T t) {
        System.out.println(t);

    }

```

###### 类型通配符

 

```java
// ?号通配符表示可以匹配任意类型，任意的Java类都可以匹配.....
//当我们使用?号通配符的时候：就只能调对象与类型无关的方法，不能调用对象与类型有关的方法。
public void test(List<?> list){

    for(int i=0;i<list.size();i++){
       
        System.out.println(list.get(i));
    
    }
}

```

###### 设定通配符上限

```java
// List集合装载的元素只能是Number的子类或自身
    public static void test(List<? extends Number> list) {
        
    }

```

###### 设定通配符下限

```java
//  //传递进来的只能是E或E的父类
public TreeSet(Comparator<? super E> comparator) {
        this(new TreeMap<>(comparator));
    }

```

###### 泛型擦除

泛型是**提供给javac编译器使用的**，它用于限定集合的输入类型，让编译器在源代码级别上，即挡住向集合中插入非法数据。但编译器编译完带有泛形的java程序后，**生成的class文件中将不再带有泛形信息**，以此使程序运行效率不受到影响，这个过程称之为“擦除”。

##### 日志系统的设计

日志用于帮助快速定位代码问题,特别是运行过程中产生的日志.

引入正交化设计,首先出来了Log4j，意思是Logfor Java。------->jdk 1.4中引入了java. util.Iogging 包,和log4j差不多.后面又出现了Logback、tinylog 等真他工具。为方便切换日志工具包,添加抽象层SimpleLogging Facade for Java，简称SLF4J

![image-20210511172642206](https://i.loli.net/2021/05/11/QX8Sfm5Zwbks764.png)

##### Spring的本质

是针对bean的生命周期进行管理的轻量级容器,是一个开放源代码的J2EE应用程序框架.

特性:  面向切面AOP;  控制反转IOC(Inversion of Control)/DI(Dependency Injection)

发展历程:

业务代码繁杂,维护困难------>抽基类,业务代码具体子类实现----->耦合性太高,有些子类并不需要父类封装的所有业务(比如日志,运行时间等),采用装饰模式----->业务与非业务代码耦合太高,他们本应该是独立(正交)的.----->运用面向切面编程AOP的思想,动态添加信息.

1.  修改现有类,编译期间增添代码,需要增强编译器,不是太好.
2. 运行期间生成代理类,添加“切面”代码然后执行
   - 使用java动态代理技术,需要有接口
   - 使用CGLib，只要业务类没有被标记为final就可以，因为宫会生成一个业务类的子类来作为代理类

![image-20210511175528914](https://i.loli.net/2021/05/11/lN4KP7quZ3pzM2B.png)

#### web

文件分类放置---->无超链接,需要找到指定文件打开---->设计出HTML( HyperText Markup Language)------>只能本地访问,无法网络共享---->放置在网络服务器,采用Http(HyperText Transfer Protocol)传输---->互联网World Wide Web  ( WWW
）的形成------->http传输不安全----->对称加密------>秘钥传输不安全------->非对称加密----->加密解密效率低下----->非对称加密传输对称加密秘钥,用对称加密秘钥进行消息的传输----->中间人劫持----->认证中心颁发数字证书----->证书传输也不安全---->数字签名,使用hash算法将公钥+个人信息生成消息摘要.原始信息+数据签名=数字证书.

单台服务器---> 多台服务器集群----->无法验证访问者是谁,是否登录过------>增加缓存服务器(Redis,mongoDB等)------>访问数据库太慢------>数据也缓存在缓存服务器中------>数据大,多台缓存服务器---->,每次访问无法准确命中------>余数算法---->增加新缓存服务器导致算法失效------->一致性Hash算法----->负载可能不均衡------>虚拟服务器,使用IP+编号----->Hash槽,每个服务器对应一个区间,存值时,通过hash算法求K的哈希值,存放在对应的槽里面.当增加服务器的时候,重新分配槽以及数据.

##### HTTP Server

![image-20210512104130574](https://i.loli.net/2021/05/12/UKaprQA3GsE8ioD.png)

![image-20210512104255604](https://i.loli.net/2021/05/12/EdrTl5y9JLxZCYA.png)

![image-20210512104446594](https://i.loli.net/2021/05/12/TamZzSMQJg7ycUK.png)

![image-20210512104540874](https://i.loli.net/2021/05/12/KAzRVNmGeBnX96g.png)

#### 代码管理

人肉版本管理---->共同协作开发时,代码冲突----->开发一个版本控制系统（ Version  Control  System,   VCS  ）,文件被一个人独占式地锁佳进行修改，
除非这个人checkin 代码，否则别人无法修改｝------>忘记checkin导致效率低下------->允许冲突,提示冲突地方,支持合并,这就是CVS, SVN-------->版本有bug,需要进行分支开发----->小步提交出现多人竞争,冲突不断导致效率低下------>添加本地私有仓库,提交在本地,后面一次性提交到服务器------->无法控制审批与权限----->添加权限,这样就出现了Git,对应的web版本系统就叫github

##### build的演进之路

 手工build----->自动化build--->脚本语言---领域特定语言（Domain Specific Language,  DSL  ),自动编译------>xml描述--->Ant---->build代码重复,保存路径不一致------>约定＞配置,固定项目结构----->maven的产生

#### 编程语言简史

浏览器语言LiveScript---->为了和java套近乎,改名叫JavaScript------>后期出现了json,于是乎HTML负责结构， css 负责展示，而我（加上AJAX、  JSON ）负责逻辑。------>ChromeV8的出现.js也能编写服务器程序了,，这就是Node.js.   

Node.js是单线程运行,基于事件驱动机制运行的,

![image-20210512144033584](https://i.loli.net/2021/05/12/H3dbyBnvKSDYzUw.png)

