>来源书籍: 小灰的算法之旅
>
>语言: Java



### 数据结构与算法

#### 基础概念

##### 数据结构

> 数据结构是数据的组织、管理和存储格式包括以下常见的结构

- 线性结构
- 树
- 图
- 其它数据结构

##### 算法

>
>算法是一系列程序指令，用于处理特定的运算和逻辑问题。衡量算法优劣的主要标准是时间复杂度和空间复杂度。

###### 时间复杂度

> 若存在函数f(n)，使得当n趋近于无穷大时，T(n)/f(n)的极限值为不等于零的常数，则称f(n)是T(n)的同数量级函数。记作T(n)=O(f(n))，称为O(f(n))，O为算法的渐进时间复杂度，简称为时间复杂度。只保留最高阶项,常数记为1.
>
> 大白话: 程序执行的时间成本

###### 空间复杂度

> 程序占用的空间大小



#### 线性数据结构

##### 数组

> 有限个相同类型的变量所组成的有序集合,每个变量被称作为元素.

###### 常用操作

- 增: 随机插入(O(n)),尾部插入(O(1)),越界插入(先扩容,再插入,时间复杂度O(n));

- 删:  随机删除(O(n)),尾部删除(O(1))
- 改: 时间复杂度O(1);
- 查: 时间复杂度O(1);

###### 优缺点

快速查找,但是写入慢.

##### 链表

###### 概念

在物理上非连续、非顺序的数据结构，由若干节点（node）所组成。

###### 单向链表

每一个节点又包含两部分，一部分是存放数据的变量data，另一部分是指向下一个节点的指针next

###### 双向链表

每一个节点除了拥有data和next指针，还拥有指向前置节点的prev 指针

###### 常用操作

- 增: 时间复杂度O(1),
- 删: 时间复杂度O(1),
- 改: 不考虑查找时间,单纯更新,时间复杂度O(1)
- 查 : 从第一个节点的指针开始遍历下一个节点,直到找到所需要的元素. 时间复杂度O(n)

##### 栈(stack)

一种线性数据结构; 先入后出  （First   In   Last   Out，简称FILO）,既可以用数组来实现，也可以用链表来实现.

###### 常见操作

- 入栈 : 增加一个元素
- 出栈 : 将栈顶元素弹出

###### 应用

- 回溯方法的调用链。比如递归调用

- 面包屑导航, 返回上一级页面

##### 队列(queue)

一种先入先出 （First   InFirst  Out，简称FIFO ）的线性数据结构,出口叫头,入口叫尾(rear). 与栈类似，队列这种数据结构既可以用数组来实现，也可以用链表来实现。

###### 常见操作

- 入队: 是把新元素放入队尾的位置，新元素的下一个位置将会成为新的队尾。

- 出队 : 将队头的元素移出,其下一个元素将成为新的队头.

###### 队列的实现

定容数组通过循环实现.  队尾指针指向的位置永远空出1位，所以队列最大容量比数组长度小1。

判断队列是否已满:

- 一种是另设一个布尔变量来判断；
- 第二种是少用一个元素空间，入队时先测试（(rear+1)%size = front）来测试满了还是还有空间；
- 第三种就是用一个计数器记录队列中的元素的总数。

![image-20210419144504569](https://raw.githubusercontent.com/tadpole145/images/main/image-20210419144504569.png)

###### 应用

- 多线程中，争夺公平锁的等待队列
- 网络爬虫实现网站抓取时，也是把待抓取的网站URL存入队列中

##### 双端队列( Double-ended queue，简称为Deque)

前端与后端都支持插入和删除操作的队列. 

![image-20210419152101714](https://raw.githubusercontent.com/tadpole145/images/main/image-20210419152101714.png)

###### 应用

存储一系列的撤销操作

##### 优先队列

谁的优先级最高，谁先出队。基于于二叉堆来实现.

##### 散列表(哈希表 )

通过key--value键值对来存储查找元素. 其本质也是一个数组,只是通过哈希函数,将Key和数组下标进行转换.不同的语言中,哈希函数的实现是不一样的.每一个对象都有属于自己的hashcode，这个hashcode是区分不同对象的重要标识。无论对象自身的类型是什么，它们的hashcode都是一个整型变量。

###### 什么是hash

Hash（哈希），又称“散列”。散列（hash）英文原意是“混杂”、“拼凑”、“重新表述”的意思。在某种程度上，散列是与排序相反的一种操作，排序是将集合中的元素按照某种方式比如字典顺序排列在一起，而散列通过计算哈希值，打破元素之间原有的关系，使集合中的元素按照散列函数的分类进行排列。 散列表可以说是数组和链表的结合

 hashCode() 表示的是对当前对象的唯一标示。计算 hashCode 的过程就称作 哈希。

###### 为什么要有 Hash

我们通常使用数组或者链表来存储元素，一旦存储的内容数量特别多，需要占用很大的空间，而且在**查找某个元素**是否存在的过程中，数组和链表都需要挨个循环比较，而通过 哈希 计算，可以大大**减少比较次数**。

###### 哈希函数

一种映射关系，根据数据的关键词 key ，通过一定的函数关系，计算出该元素存储位置的函数

###### 常见的哈希函数构造方法

- 直接定址法

取关键字或关键字的某个线性函数值为散列地址。即 H(key) = key 或 H(key) = a*key + b，其中a和b为常数

- 除留余数法

取关键字被某个不大于散列表长度 m 的数 p 求余，得到的作为散列地址。即 H(key) = key % p, p < m。 

- 数字分析法

当关键字的位数大于地址的位数，对关键字的各位分布进行分析，选出分布均匀的任意几位作为散列地址。仅适用于所有关键字都已知的情况下，根据实际应用确定要选取的部分，尽量避免发生冲突。

- 平方取中法

先计算出关键字值的平方，然后取平方值中间几位作为散列地址。随机分布的关键字，得到的散列地址也是随机分布的。

- 折叠法（叠加法）

将关键字分为位数相同的几部分，然后取这几部分的叠加和（舍去进位）作为散列地址。用于关键字位数较多，并且关键字中每一位上数字分布大致均匀。

- 随机数法

选择一个随机函数，把关键字的随机函数值作为它的哈希值。

###### 哈希冲突的解决

- 链接法（拉链法）

将所有关键字为同义词的结点链接在同一个单链表中。

- ==开放定址法==

使用某种探查(亦称探测)技术在散列表中寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到。在Java中，ThreadLocal所使用的就是开放寻址法。

- ==链表法== (java中的hashMap使用此法)

HashMap数组的每一个元素不仅是一个Entry对象，还是一个链表的头节点。每一个Entry对象通过next指针指向它的下一个Entry节点。当新来的Entry映射到与之冲突的数组位置时，只需要插入到对应的链表中即可。

当经过多次元素插入，散列表达到一定饱和度时，Key映射位置发生冲突的概率会逐渐提高。大量元素拥挤在相同的数组下标位置，形成很长的链表，对后续插入操作和查询操作的性能都有很大影响。这时就需要对散列表进行扩容.

对HashMap来说,影响扩容的影子有2个:

- Capacity ，即HashMap的当前长度
- LoadFactor ，即HashMap的负载因子，默认值为0.75f

###### 如今扩容?

- 创建一个新的Entry空数组，长度是原数组的2倍。
- 重新Hash. 遍历原Entry数组，把所有的Entry重新Hash到新数组中。为什么要重新Hash呢？因为长度扩大以后，Hash的规则也随之改变。

JDK    8和以前的版本有着很大的不同。当多个Entry被Hash到同一个数组下标位置时，为了提升插入和查找的效率，HashMap会把Entry的链表转化为红黑树这种数据结构。



###### 哈希的应用

- 哈希表
- 分布式缓存